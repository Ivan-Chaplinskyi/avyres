((t, i) => {
  "object" == typeof exports && "undefined" != typeof module ? module.exports = i() : "function" == typeof define && define.amd ? define(i) : (t = "undefined" != typeof globalThis ? globalThis : t || self).PhotoSwipe = i()
})(this, function() {
  function l(t, i, e) {
    i = document.createElement(i);
    return t && (i.className = t), e && e.appendChild(i), i
  }

  function c(t, i) {
    return t.x = i.x, t.y = i.y, void 0 !== i.id && (t.id = i.id), t
  }

  function o(t) {
    t.x = Math.round(t.x), t.y = Math.round(t.y)
  }

  function p(t, i) {
    var e = Math.abs(t.x - i.x),
      t = Math.abs(t.y - i.y);
    return Math.sqrt(e * e + t * t)
  }

  function m(t, i) {
    return t.x === i.x && t.y === i.y
  }

  function u(t, i, e) {
    return Math.min(Math.max(t, i), e)
  }

  function a(t, i, e) {
    let s = `translate3d(${t}px,${i||0}px,0)`;
    return void 0 !== e && (s += ` scale3d(${e},${e},1)`), s
  }

  function r(t, i, e, s) {
    t.style.transform = a(i, e, s)
  }

  function d(t, i, e, s) {
    t.style.transition = i ? i + ` ${e}ms ` + (s || "cubic-bezier(.4,0,.22,1)") : "none"
  }

  function s(t, i, e) {
    t.style.width = "number" == typeof i ? i + "px" : i, t.style.height = "number" == typeof e ? e + "px" : e
  }
  let e = "loading",
    t = "loaded",
    i = "error";

  function n() {
    return navigator.vendor && navigator.vendor.match(/apple/i)
  }
  let v = !1;
  try {
    window.addEventListener("test", null, Object.defineProperty({}, "passive", {
      get: () => {
        v = !0
      }
    }))
  } catch (l) {}
  class h {
    constructor() {
      this.t = []
    }
    add(t, i, e, s) {
      this.i(t, i, e, s)
    }
    remove(t, i, e, s) {
      this.i(t, i, e, s, !0)
    }
    removeAll() {
      this.t.forEach(t => {
        this.i(t.target, t.type, t.listener, t.passive, !0, !0)
      }), this.t = []
    }
    i(s, t, n, h, o, a) {
      if (s) {
        let e = o ? "removeEventListener" : "addEventListener";
        t.split(" ").forEach(i => {
          var t;
          i && (a || (o ? this.t = this.t.filter(t => t.type !== i || t.listener !== n || t.target !== s) : this.t.push({
            target: s,
            type: i,
            listener: n,
            passive: h
          })), t = !!v && {
            passive: h || !1
          }, s[e](i, n, t))
        })
      }
    }
  }

  function g(t, i) {
    if (t.getViewportSizeFn) {
      t = t.getViewportSizeFn(t, i);
      if (t) return t
    }
    return {
      x: document.documentElement.clientWidth,
      y: window.innerHeight
    }
  }

  function y(i, e, t, s, n) {
    let h = 0;
    if (e.paddingFn) h = e.paddingFn(t, s, n)[i];
    else if (e.padding) h = e.padding[i];
    else {
      let t = "padding" + i[0].toUpperCase() + i.slice(1);
      e[t] && (h = e[t])
    }
    return Number(h) || 0
  }

  function w(t, i, e, s) {
    return {
      x: i.x - y("left", t, i, e, s) - y("right", t, i, e, s),
      y: i.y - y("top", t, i, e, s) - y("bottom", t, i, e, s)
    }
  }
  class f {
    constructor(t) {
      this.slide = t, this.currZoomLevel = 1, this.center = {
        x: 0,
        y: 0
      }, this.max = {
        x: 0,
        y: 0
      }, this.min = {
        x: 0,
        y: 0
      }
    }
    update(t) {
      this.currZoomLevel = t, this.slide.width ? (this.o("x"), this.o("y"), this.slide.pswp.dispatch("calcBounds", {
        slide: this.slide
      })) : this.reset()
    }
    o(t) {
      var i = this.slide.pswp,
        e = this.slide["x" === t ? "width" : "height"] * this.currZoomLevel,
        i = y("x" === t ? "left" : "top", i.options, i.viewportSize, this.slide.data, this.slide.index),
        s = this.slide.panAreaSize[t];
      this.center[t] = Math.round((s - e) / 2) + i, this.max[t] = s < e ? Math.round(s - e) + i : this.center[t], this.min[t] = s < e ? i : this.center[t]
    }
    reset() {
      this.center.x = 0, this.center.y = 0, this.max.x = 0, this.max.y = 0, this.min.x = 0, this.min.y = 0
    }
    correctPan(t, i) {
      return u(i, this.max[t], this.min[t])
    }
  }
  class x {
    constructor(t, i, e, s) {
      this.pswp = s, this.options = t, this.itemData = i, this.index = e, this.panAreaSize = null, this.elementSize = null, this.fit = 1, this.fill = 1, this.vFill = 1, this.initial = 1, this.secondary = 1, this.max = 1, this.min = 1
    }
    update(t, i, e) {
      t = {
        x: t,
        y: i
      }, this.elementSize = t, i = (this.panAreaSize = e).x / t.x, e = e.y / t.y;
      this.fit = Math.min(1, i < e ? i : e), this.fill = Math.min(1, e < i ? i : e), this.vFill = Math.min(1, e), this.initial = this.l(), this.secondary = this.u(), this.max = Math.max(this.initial, this.secondary, this.p()), this.min = Math.min(this.fit, this.initial, this.secondary), this.pswp && this.pswp.dispatch("zoomLevelsUpdate", {
        zoomLevels: this,
        slideData: this.itemData
      })
    }
    m(t) {
      t = this.options[t + "ZoomLevel"];
      if (t) return "function" == typeof t ? t(this) : "fill" === t ? this.fill : "fit" === t ? this.fit : Number(t)
    }
    u() {
      let t = this.m("secondary");
      return t || (t = Math.min(1, 3 * this.fit), t = this.elementSize && 4e3 < t * this.elementSize.x ? 4e3 / this.elementSize.x : t)
    }
    l() {
      return this.m("initial") || this.fit
    }
    p() {
      return this.m("max") || Math.max(1, 4 * this.fit)
    }
  }
  class S {
    constructor(t, i, e) {
      this.data = t, this.index = i, this.pswp = e, this.isActive = i === e.currIndex, this.currentResolution = 0, this.panAreaSize = {
        x: 0,
        y: 0
      }, this.pan = {
        x: 0,
        y: 0
      }, this.isFirstSlide = this.isActive && !e.opener.isOpen, this.zoomLevels = new x(e.options, t, i, e), this.pswp.dispatch("gettingData", {
        slide: this,
        data: this.data,
        index: i
      }), this.content = this.pswp.contentLoader.getContentBySlide(this), this.container = l("pswp__zoom-wrap", "div"), this.holderElement = null, this.currZoomLevel = 1, this.width = this.content.width, this.height = this.content.height, this.heavyAppended = !1, this.bounds = new f(this), this.prevDisplayedWidth = -1, this.prevDisplayedHeight = -1, this.pswp.dispatch("slideInit", {
        slide: this
      })
    }
    setIsActive(t) {
      t && !this.isActive ? this.activate() : !t && this.isActive && this.deactivate()
    }
    append(t) {
      this.holderElement = t, this.container.style.transformOrigin = "0 0", this.data && (this.calculateSize(), this.load(), this.updateContentSize(), this.appendHeavy(), this.holderElement.appendChild(this.container), this.zoomAndPanToInitial(), this.pswp.dispatch("firstZoomPan", {
        slide: this
      }), this.applyCurrentZoomPan(), this.pswp.dispatch("afterSetContent", {
        slide: this
      }), this.isActive) && this.activate()
    }
    load() {
      this.content.load(!1), this.pswp.dispatch("slideLoad", {
        slide: this
      })
    }
    appendHeavy() {
      var t = this.pswp;
      this.heavyAppended || !t.opener.isOpen || t.mainScroll.isShifted() || (this.isActive, 0) || this.pswp.dispatch("appendHeavy", {
        slide: this
      }).defaultPrevented || (this.heavyAppended = !0, this.content.append(), this.pswp.dispatch("appendHeavyContent", {
        slide: this
      }))
    }
    activate() {
      this.isActive = !0, this.appendHeavy(), this.content.activate(), this.pswp.dispatch("slideActivate", {
        slide: this
      })
    }
    deactivate() {
      this.isActive = !1, this.content.deactivate(), this.currZoomLevel !== this.zoomLevels.initial && this.calculateSize(), this.currentResolution = 0, this.zoomAndPanToInitial(), this.applyCurrentZoomPan(), this.updateContentSize(), this.pswp.dispatch("slideDeactivate", {
        slide: this
      })
    }
    destroy() {
      this.content.hasSlide = !1, this.content.remove(), this.container.remove(), this.pswp.dispatch("slideDestroy", {
        slide: this
      })
    }
    resize() {
      this.currZoomLevel !== this.zoomLevels.initial && this.isActive ? (this.calculateSize(), this.bounds.update(this.currZoomLevel), this.panTo(this.pan.x, this.pan.y)) : (this.calculateSize(), this.currentResolution = 0, this.zoomAndPanToInitial(), this.applyCurrentZoomPan(), this.updateContentSize())
    }
    updateContentSize(t) {
      var i, e = this.currentResolution || this.zoomLevels.initial;
      e && (i = Math.round(this.width * e) || this.pswp.viewportSize.x, e = Math.round(this.height * e) || this.pswp.viewportSize.y, this.sizeChanged(i, e) || t) && this.content.setDisplayedSize(i, e)
    }
    sizeChanged(t, i) {
      return (t !== this.prevDisplayedWidth || i !== this.prevDisplayedHeight) && (this.prevDisplayedWidth = t, this.prevDisplayedHeight = i, !0)
    }
    getPlaceholderElement() {
      var t;
      return null == (t = this.content.placeholder) ? void 0 : t.element
    }
    zoomTo(t, i, e, s) {
      var n, h = this.pswp;
      this.isZoomable() && !h.mainScroll.isShifted() && (h.dispatch("beforeZoomTo", {
        destZoomLevel: t,
        centerPoint: i,
        transitionDuration: e
      }), h.animations.stopAllPan(), n = this.currZoomLevel, s || (t = u(t, this.zoomLevels.min, this.zoomLevels.max)), this.setZoomLevel(t), this.pan.x = this.calculateZoomToPanOffset("x", i, n), this.pan.y = this.calculateZoomToPanOffset("y", i, n), o(this.pan), s = () => {
        this.v(t), this.applyCurrentZoomPan()
      }, e ? h.animations.startTransition({
        isPan: !0,
        name: "zoomTo",
        target: this.container,
        transform: this.getCurrentTransform(),
        onComplete: s,
        duration: e,
        easing: h.options.easing
      }) : s())
    }
    toggleZoom(t) {
      this.zoomTo(this.currZoomLevel === this.zoomLevels.initial ? this.zoomLevels.secondary : this.zoomLevels.initial, t, this.pswp.options.zoomAnimationDuration)
    }
    setZoomLevel(t) {
      this.currZoomLevel = t, this.bounds.update(this.currZoomLevel)
    }
    calculateZoomToPanOffset(t, i, e) {
      if (0 == this.bounds.max[t] - this.bounds.min[t]) return this.bounds.center[t];
      i = i || this.pswp.getViewportCenterPoint(), e = e || this.zoomLevels.initial;
      e = this.currZoomLevel / e;
      return this.bounds.correctPan(t, (this.pan[t] - i[t]) * e + i[t])
    }
    panTo(t, i) {
      this.pan.x = this.bounds.correctPan("x", t), this.pan.y = this.bounds.correctPan("y", i), this.applyCurrentZoomPan()
    }
    isPannable() {
      return Boolean(this.width) && this.currZoomLevel > this.zoomLevels.fit
    }
    isZoomable() {
      return Boolean(this.width) && this.content.isZoomable()
    }
    applyCurrentZoomPan() {
      this.g(this.pan.x, this.pan.y, this.currZoomLevel), this === this.pswp.currSlide && this.pswp.dispatch("zoomPanUpdate", {
        slide: this
      })
    }
    zoomAndPanToInitial() {
      this.currZoomLevel = this.zoomLevels.initial, this.bounds.update(this.currZoomLevel), c(this.pan, this.bounds.center), this.pswp.dispatch("initialZoomPan", {
        slide: this
      })
    }
    g(t, i, e) {
      e /= this.currentResolution || this.zoomLevels.initial, r(this.container, t, i, e)
    }
    calculateSize() {
      var t = this.pswp;
      c(this.panAreaSize, w(t.options, t.viewportSize, this.data, this.index)), this.zoomLevels.update(this.width, this.height, this.panAreaSize), t.dispatch("calcSlideSize", {
        slide: this
      })
    }
    getCurrentTransform() {
      var t = this.currZoomLevel / (this.currentResolution || this.zoomLevels.initial);
      return a(this.pan.x, this.pan.y, t)
    }
    v(t) {
      t !== this.currentResolution && (this.currentResolution = t, this.updateContentSize(), this.pswp.dispatch("resolutionChanged"))
    }
  }
  class b {
    constructor(t) {
      this.gestures = t, this.pswp = t.pswp, this.startPan = {
        x: 0,
        y: 0
      }
    }
    start() {
      this.pswp.currSlide && c(this.startPan, this.pswp.currSlide.pan), this.pswp.animations.stopAll()
    }
    change() {
      let {
        p1: t,
        prevP1: e,
        dragAxis: i
      } = this.gestures, s = this.pswp.currSlide;
      if ("y" === i && this.pswp.options.closeOnVerticalDrag && s && s.currZoomLevel <= s.zoomLevels.fit && !this.gestures.isMultitouch) {
        let i = s.pan.y + (t.y - e.y);
        if (!this.pswp.dispatch("verticalDrag", {
            panY: i
          }).defaultPrevented) {
          this._("y", i, .6);
          let t = 1 - Math.abs(this.S(s.pan.y));
          this.pswp.applyBgOpacity(t), s.applyCurrentZoomPan()
        }
      } else this.M("x") || (this.M("y"), s && (o(s.pan), s.applyCurrentZoomPan()))
    }
    end() {
      let i = this.gestures.velocity,
        {
          mainScroll: e,
          currSlide: t
        } = this.pswp,
        s = 0;
      if (this.pswp.animations.stopAll(), e.isShifted()) {
        let t = (e.x - e.getCurrSlideX()) / this.pswp.viewportSize.x;
        i.x < -.5 && t < 0 || i.x < .1 && t < -.5 ? (s = 1, i.x = Math.min(i.x, 0)) : (.5 < i.x && 0 < t || -.1 < i.x && .5 < t) && (s = -1, i.x = Math.max(i.x, 0)), e.moveIndexBy(s, !0, i.x)
      }
      t && t.currZoomLevel > t.zoomLevels.max || this.gestures.isMultitouch ? this.gestures.zoomLevels.correctZoomPan(!0) : (this.P("x"), this.P("y"))
    }
    P(l) {
      let i = this.gestures.velocity,
        p = this.pswp.currSlide;
      if (p) {
        let {
          pan: n,
          bounds: t
        } = p, h = n[l], o = this.pswp.bgOpacity < 1 && "y" === l, a = h + .995 * i[l] / (1 - .995);
        if (o) {
          let t = this.S(h),
            i = this.S(a);
          if (t < 0 && i < -.4 || 0 < t && .4 < i) return void this.pswp.close()
        }
        let r = t.correctPan(l, a);
        if (h !== r) {
          let t = r === a ? 1 : .82,
            e = this.pswp.bgOpacity,
            s = r - h;
          this.pswp.animations.startSpring({
            name: "panGesture" + l,
            isPan: !0,
            start: h,
            end: r,
            velocity: i[l],
            dampingRatio: t,
            onUpdate: i => {
              if (o && this.pswp.bgOpacity < 1) {
                let t = 1 - (r - i) / s;
                this.pswp.applyBgOpacity(u(e + (1 - e) * t, 0, 1))
              }
              n[l] = Math.floor(i), p.applyCurrentZoomPan()
            }
          })
        }
      }
    }
    M(n) {
      let {
        p1: t,
        dragAxis: i,
        prevP1: e,
        isMultitouch: s
      } = this.gestures, {
        currSlide: h,
        mainScroll: o
      } = this.pswp, a = t[n] - e[n], r = o.x + a;
      if (a && h) {
        if ("x" === n && !h.isPannable() && !s) return o.moveTo(r, !0), !0;
        var l = h.bounds,
          p = h.pan[n] + a;
        if (this.pswp.options.allowPanToNext && "x" === i && "x" === n && !s) {
          let t = o.getCurrSlideX(),
            i = o.x - t,
            e = 0 < a,
            s = !e;
          if (p > l.min[n] && e) {
            if (l.min[n] <= this.startPan[n]) return o.moveTo(r, !0), !0;
            this._(n, p)
          } else if (p < l.max[n] && s) {
            if (this.startPan[n] <= l.max[n]) return o.moveTo(r, !0), !0;
            this._(n, p)
          } else if (0 != i) {
            if (0 < i) return o.moveTo(Math.max(r, t), !0), !0;
            if (i < 0) return o.moveTo(Math.min(r, t), !0), !0
          } else this._(n, p)
        } else "y" === n && (o.isShifted() || l.min.y === l.max.y) || this._(n, p)
      }
      return !1
    }
    S(t) {
      return (t - (null != (t = null == (t = this.pswp.currSlide) ? void 0 : t.bounds.center.y) ? t : 0)) / (this.pswp.viewportSize.y / 3)
    }
    _(i, e, s) {
      let t = this.pswp.currSlide;
      if (t) {
        var {
          pan: n,
          bounds: h
        } = t;
        if (h.correctPan(i, e) !== e || s) {
          let t = Math.round(e - n[i]);
          n[i] += t * (s || .35)
        } else n[i] = e
      }
    }
  }

  function z(t, i, e) {
    t.x = (i.x + e.x) / 2, t.y = (i.y + e.y) / 2
  }
  class P {
    constructor(t) {
      this.gestures = t, this.C = {
        x: 0,
        y: 0
      }, this.T = {
        x: 0,
        y: 0
      }, this.A = {
        x: 0,
        y: 0
      }, this.D = !1, this.I = 1
    }
    start() {
      var t = this.gestures.pswp.currSlide;
      t && (this.I = t.currZoomLevel, c(this.C, t.pan)), this.gestures.pswp.animations.stopAllPan(), this.D = !1
    }
    change() {
      let {
        p1: t,
        startP1: e,
        p2: s,
        startP2: n,
        pswp: h
      } = this.gestures, o = h.currSlide;
      if (o) {
        var a = o.zoomLevels.min,
          r = o.zoomLevels.max;
        if (o.isZoomable() && !h.mainScroll.isShifted()) {
          z(this.T, e, n), z(this.A, t, s);
          let i = 1 / p(e, n) * p(t, s) * this.I;
          if (i > o.zoomLevels.initial + o.zoomLevels.initial / 15 && (this.D = !0), i < a)
            if (h.options.pinchToClose && !this.D && this.I <= o.zoomLevels.initial) {
              let t = 1 - (a - i) / (a / 1.2);
              h.dispatch("pinchClose", {
                bgOpacity: t
              }).defaultPrevented || h.applyBgOpacity(t)
            } else i = a - .15 * (a - i);
          else i > r && (i = r + .05 * (i - r));
          o.pan.x = this.L("x", i), o.pan.y = this.L("y", i), o.setZoomLevel(i), o.applyCurrentZoomPan()
        }
      }
    }
    end() {
      var t = this.gestures.pswp,
        i = t.currSlide;
      (!i || i.currZoomLevel < i.zoomLevels.initial) && !this.D && t.options.pinchToClose ? t.close() : this.correctZoomPan()
    }
    L(t, i) {
      i /= this.I;
      return this.A[t] - (this.T[t] - this.C[t]) * i
    }
    correctZoomPan(t) {
      let p = this.gestures.pswp,
        d = p.currSlide;
      if (null != d && d.isZoomable()) {
        0 === this.A.x && (t = !0);
        let e = d.currZoomLevel,
          s, n = !0,
          h = (s = e < d.zoomLevels.initial ? d.zoomLevels.initial : e > d.zoomLevels.max ? d.zoomLevels.max : (n = !1, e), p.bgOpacity),
          o = p.bgOpacity < 1,
          a = c({
            x: 0,
            y: 0
          }, d.pan),
          r = c({
            x: 0,
            y: 0
          }, a),
          l = (t && (this.A.x = 0, this.A.y = 0, this.T.x = 0, this.T.y = 0, this.I = e, c(this.C, a)), n && (r = {
            x: this.L("x", s),
            y: this.L("y", s)
          }), d.setZoomLevel(s), r = {
            x: d.bounds.correctPan("x", r.x),
            y: d.bounds.correctPan("y", r.y)
          }, d.setZoomLevel(e), !m(r, a));
        l || n || o ? (p.animations.stopAllPan(), p.animations.startSpring({
          isPan: !0,
          start: 0,
          end: 1e3,
          velocity: 0,
          dampingRatio: 1,
          naturalFrequency: 40,
          onUpdate: t => {
            var i;
            t /= 1e3, (l || n) && (l && (d.pan.x = a.x + (r.x - a.x) * t, d.pan.y = a.y + (r.y - a.y) * t), n && (i = e + (s - e) * t, d.setZoomLevel(i)), d.applyCurrentZoomPan()), o && p.bgOpacity < 1 && p.applyBgOpacity(u(h + (1 - h) * t, 0, 1))
          },
          onComplete: () => {
            d.v(s), d.applyCurrentZoomPan()
          }
        })) : (d.v(s), d.applyCurrentZoomPan())
      }
    }
  }

  function I(t) {
    return t.target.closest(".pswp__container")
  }
  class L {
    constructor(t) {
      this.gestures = t
    }
    click(t, i) {
      var e = i.target.classList,
        s = e.contains("pswp__img"),
        e = e.contains("pswp__item") || e.contains("pswp__zoom-wrap");
      s ? this.k("imageClick", t, i) : e && this.k("bgClick", t, i)
    }
    tap(t, i) {
      I(i) && this.k("tap", t, i)
    }
    doubleTap(t, i) {
      I(i) && this.k("doubleTap", t, i)
    }
    k(t, i, e) {
      var s, n = this.gestures.pswp,
        h = n.currSlide,
        t = t + "Action",
        o = n.options[t];
      if (!n.dispatch(t, {
          point: i,
          originalEvent: e
        }).defaultPrevented)
        if ("function" != typeof o) switch (o) {
          case "close":
          case "next":
            n[o]();
            break;
          case "zoom":
            null != h && h.toggleZoom(i);
            break;
          case "zoom-or-close":
            null != h && h.isZoomable() && h.zoomLevels.secondary !== h.zoomLevels.initial ? h.toggleZoom(i) : n.options.clickToCloseNonZoomable && n.close();
            break;
          case "toggle-controls":
            null != (s = this.gestures.pswp.element) && s.classList.toggle("pswp--ui-visible")
        } else o.call(n, i, e)
    }
  }
  class C {
    constructor(t) {
      this.pswp = t, this.dragAxis = null, this.p1 = {
        x: 0,
        y: 0
      }, this.p2 = {
        x: 0,
        y: 0
      }, this.prevP1 = {
        x: 0,
        y: 0
      }, this.prevP2 = {
        x: 0,
        y: 0
      }, this.startP1 = {
        x: 0,
        y: 0
      }, this.startP2 = {
        x: 0,
        y: 0
      }, this.velocity = {
        x: 0,
        y: 0
      }, this.Z = {
        x: 0,
        y: 0
      }, this.B = {
        x: 0,
        y: 0
      }, this.F = 0, this.O = [], this.R = "ontouchstart" in window, this.N = !!window.PointerEvent, this.supportsTouch = this.R || this.N && 1 < navigator.maxTouchPoints, this.F = 0, this.U = 0, this.V = !1, this.isMultitouch = !1, this.isDragging = !1, this.isZooming = !1, this.raf = null, this.G = null, this.supportsTouch || (t.options.allowPanToNext = !1), this.drag = new b(this), this.zoomLevels = new P(this), this.tapHandler = new L(this), t.on("bindEvents", () => {
        t.events.add(t.scrollWrap, "click", this.$.bind(this)), this.N ? this.q("pointer", "down", "up", "cancel") : this.R ? (this.q("touch", "start", "end", "cancel"), t.scrollWrap && (t.scrollWrap.ontouchmove = () => {}, t.scrollWrap.ontouchend = () => {})) : this.q("mouse", "down", "up")
      })
    }
    q(t, i, e, s) {
      var n = this.pswp,
        h = n.events,
        s = s ? t + s : "";
      h.add(n.scrollWrap, t + i, this.onPointerDown.bind(this)), h.add(window, t + "move", this.onPointerMove.bind(this)), h.add(window, t + e, this.onPointerUp.bind(this)), s && h.add(n.scrollWrap, s, this.onPointerUp.bind(this))
    }
    onPointerDown(t) {
      var i, e = "mousedown" === t.type || "mouse" === t.pointerType;
      e && 0 < t.button || (i = this.pswp, i.opener.isOpen ? i.dispatch("pointerDown", {
        originalEvent: t
      }).defaultPrevented || (e && (i.mouseDetected(), this.H(t, "down")), i.animations.stopAll(), this.K(t, "down"), 1 === this.F && (this.dragAxis = null, c(this.startP1, this.p1)), 1 < this.F ? (this.W(), this.isMultitouch = !0) : this.isMultitouch = !1) : t.preventDefault())
    }
    onPointerMove(t) {
      this.H(t, "move"), this.F && (this.K(t, "move"), this.pswp.dispatch("pointerMove", {
        originalEvent: t
      }).defaultPrevented || (1 !== this.F || this.isDragging ? 1 < this.F && !this.isZooming && (this.j(), this.isZooming = !0, this.X(), this.zoomLevels.start(), this.Y(), this.J()) : (this.dragAxis || this.tt(), this.dragAxis && !this.isDragging && (this.isZooming && (this.isZooming = !1, this.zoomLevels.end()), this.isDragging = !0, this.W(), this.X(), this.U = Date.now(), this.V = !1, c(this.B, this.p1), this.velocity.x = 0, this.velocity.y = 0, this.drag.start(), this.Y(), this.J()))))
    }
    j() {
      this.isDragging && (this.isDragging = !1, this.V || this.it(!0), this.drag.end(), this.dragAxis = null)
    }
    onPointerUp(t) {
      this.F && (this.K(t, "up"), this.pswp.dispatch("pointerUp", {
        originalEvent: t
      }).defaultPrevented || (0 === this.F && (this.Y(), this.isDragging ? this.j() : this.isZooming || this.isMultitouch || this.st(t)), this.F < 2 && this.isZooming && (this.isZooming = !1, this.zoomLevels.end(), 1 === this.F) && (this.dragAxis = null, this.X())))
    }
    J() {
      (this.isDragging || this.isZooming) && (this.it(), this.isDragging ? m(this.p1, this.prevP1) || this.drag.change() : m(this.p1, this.prevP1) && m(this.p2, this.prevP2) || this.zoomLevels.change(), this.ht(), this.raf = requestAnimationFrame(this.J.bind(this)))
    }
    it(t) {
      var i = Date.now(),
        e = i - this.U;
      e < 50 && !t || (this.velocity.x = this.et("x", e), this.velocity.y = this.et("y", e), this.U = i, c(this.B, this.p1), this.V = !0)
    }
    st(t) {
      var i = this.pswp.mainScroll;
      i.isShifted() ? i.moveIndexBy(0, !0) : 0 < t.type.indexOf("cancel") || ("mouseup" === t.type || "mouse" === t.pointerType ? this.tapHandler.click(this.startP1, t) : (i = this.pswp.options.doubleTapAction ? 300 : 0, this.G ? (this.W(), p(this.Z, this.startP1) < 25 && this.tapHandler.doubleTap(this.startP1, t)) : (c(this.Z, this.startP1), this.G = setTimeout(() => {
        this.tapHandler.tap(this.startP1, t), this.W()
      }, i))))
    }
    W() {
      this.G && (clearTimeout(this.G), this.G = null)
    }
    et(t, i) {
      t = this.p1[t] - this.B[t];
      return 1 < Math.abs(t) && 5 < i ? t / i : 0
    }
    Y() {
      this.raf && (cancelAnimationFrame(this.raf), this.raf = null)
    }
    H(t, i) {
      this.pswp.applyFilters("preventPointerEvent", !0, t, i) && t.preventDefault()
    }
    K(e, s) {
      if (this.N) {
        let i = e,
          t = this.O.findIndex(t => t.id === i.pointerId);
        "up" === s && -1 < t ? this.O.splice(t, 1) : "down" === s && -1 === t ? this.O.push(this.nt(i, {
          x: 0,
          y: 0
        })) : -1 < t && this.nt(i, this.O[t]), this.F = this.O.length, 0 < this.F && c(this.p1, this.O[0]), 1 < this.F && c(this.p2, this.O[1])
      } else {
        let t = e;
        this.F = 0, -1 < t.type.indexOf("touch") ? t.touches && 0 < t.touches.length && (this.nt(t.touches[0], this.p1), this.F++, 1 < t.touches.length) && (this.nt(t.touches[1], this.p2), this.F++) : (this.nt(e, this.p1), "up" === s ? this.F = 0 : this.F++)
      }
    }
    ht() {
      c(this.prevP1, this.p1), c(this.prevP2, this.p2)
    }
    X() {
      c(this.startP1, this.p1), c(this.startP2, this.p2), this.ht()
    }
    tt() {
      var t;
      this.pswp.mainScroll.isShifted() ? this.dragAxis = "x" : 0 != (t = Math.abs(this.p1.x - this.startP1.x) - Math.abs(this.p1.y - this.startP1.y)) && (t = 0 < t ? "x" : "y", 10 <= Math.abs(this.p1[t] - this.startP1[t])) && (this.dragAxis = t)
    }
    nt(t, i) {
      return i.x = t.pageX - this.pswp.offset.x, i.y = t.pageY - this.pswp.offset.y, "pointerId" in t ? i.id = t.pointerId : void 0 !== t.identifier && (i.id = t.identifier), i
    }
    $(t) {
      this.pswp.mainScroll.isShifted() && (t.preventDefault(), t.stopPropagation())
    }
  }
  class A {
    constructor(t) {
      this.pswp = t, this.x = 0, this.slideWidth = 0, this.ot = 0, this.rt = 0, this.lt = -1, this.itemHolders = []
    }
    resize(e) {
      let t = this.pswp,
        i = Math.round(t.viewportSize.x + t.viewportSize.x * t.options.spacing),
        s = i !== this.slideWidth;
      s && (this.slideWidth = i, this.moveTo(this.getCurrSlideX())), this.itemHolders.forEach((t, i) => {
        s && r(t.el, (i + this.lt) * this.slideWidth), e && t.slide && t.slide.resize()
      })
    }
    resetPosition() {
      this.ot = 0, this.rt = 0, this.slideWidth = 0, this.lt = -1
    }
    appendHolders() {
      this.itemHolders = [];
      for (let t = 0; t < 3; t++) {
        var i = l("pswp__item", "div", this.pswp.container);
        i.setAttribute("role", "group"), i.setAttribute("aria-roledescription", "slide"), i.setAttribute("aria-hidden", "true"), i.style.display = 1 === t ? "block" : "none", this.itemHolders.push({
          el: i
        })
      }
    }
    canBeSwiped() {
      return 1 < this.pswp.getNumItems()
    }
    moveIndexBy(i, t, e) {
      let s = this.pswp,
        n = s.potentialIndex + i;
      var h = s.getNumItems();
      if (s.canLoop()) {
        n = s.getLoopedIndex(n);
        let t = (i + h) % h;
        i = t <= h / 2 ? t : t - h
      } else n < 0 ? n = 0 : n >= h && (n = h - 1), i = n - s.potentialIndex;
      s.potentialIndex = n, this.ot -= i, s.animations.stopMainScroll();
      var o = this.getCurrSlideX();
      if (t) {
        s.animations.startSpring({
          isMainScroll: !0,
          start: this.x,
          end: o,
          velocity: e || 0,
          naturalFrequency: 30,
          dampingRatio: 1,
          onUpdate: t => {
            this.moveTo(t)
          },
          onComplete: () => {
            this.updateCurrItem(), s.appendHeavy()
          }
        });
        let i = s.potentialIndex - s.currIndex;
        if (s.canLoop()) {
          let t = (i + h) % h;
          i = t <= h / 2 ? t : t - h
        }
        1 < Math.abs(i) && this.updateCurrItem()
      } else this.moveTo(o), this.updateCurrItem();
      return Boolean(i)
    }
    getCurrSlideX() {
      return this.slideWidth * this.ot
    }
    isShifted() {
      return this.x !== this.getCurrSlideX()
    }
    updateCurrItem() {
      var t, s = this.pswp,
        n = this.rt - this.ot;
      if (n) {
        this.rt = this.ot, s.currIndex = s.potentialIndex;
        let i, e = Math.abs(n);
        3 <= e && (this.lt += n + (0 < n ? -3 : 3), e = 3, this.itemHolders.forEach(t => {
          var i;
          null != (i = t.slide) && i.destroy(), t.slide = void 0
        }));
        for (let t = 0; t < e; t++) 0 < n ? (i = this.itemHolders.shift()) && (this.itemHolders[2] = i, this.lt++, r(i.el, (this.lt + 2) * this.slideWidth), s.setContent(i, s.currIndex - e + t + 2)) : (i = this.itemHolders.pop()) && (this.itemHolders.unshift(i), this.lt--, r(i.el, this.lt * this.slideWidth), s.setContent(i, s.currIndex + e - t - 2));
        50 < Math.abs(this.lt) && !this.isShifted() && (this.resetPosition(), this.resize()), s.animations.stopAllPan(), this.itemHolders.forEach((t, i) => {
          t.slide && t.slide.setIsActive(1 === i)
        }), s.currSlide = null == (t = this.itemHolders[1]) ? void 0 : t.slide, s.contentLoader.updateLazy(n), s.currSlide && s.currSlide.applyCurrentZoomPan(), s.dispatch("change")
      }
    }
    moveTo(t, i) {
      var e, s;
      !this.pswp.canLoop() && i && (e = (this.slideWidth * this.ot - t) / this.slideWidth, e += this.pswp.currIndex, s = Math.round(t - this.x), e < 0 && 0 < s || e >= this.pswp.getNumItems() - 1 && s < 0) && (t = this.x + .35 * s), this.x = t, this.pswp.container && r(this.pswp.container, t), this.pswp.dispatch("moveMainScroll", {
        x: t,
        dragging: null != i && i
      })
    }
  }
  let D = {
      Escape: 27,
      z: 90,
      ArrowLeft: 37,
      ArrowUp: 38,
      ArrowRight: 39,
      ArrowDown: 40,
      Tab: 9
    },
    T = (t, i) => i ? t : D[t];
  class Z {
    constructor(t) {
      this.pswp = t, this.ct = !1, t.on("bindEvents", () => {
        t.options.trapFocus && (t.options.initialPointerPos || this.dt(), t.events.add(document, "focusin", this.ut.bind(this))), t.events.add(document, "keydown", this.vt.bind(this))
      });
      let i = document.activeElement;
      t.on("destroy", () => {
        t.options.returnFocus && i && this.ct && i.focus()
      })
    }
    dt() {
      !this.ct && this.pswp.element && (this.pswp.element.focus(), this.ct = !0)
    }
    vt(n) {
      var t, h = this.pswp;
      if (!h.dispatch("keydown", {
          originalEvent: n
        }).defaultPrevented && !("button" in (t = n) && 1 === t.button || t.ctrlKey || t.metaKey || t.altKey || t.shiftKey)) {
        let i, e, s = !1,
          t = "key" in n;
        switch (t ? n.key : n.keyCode) {
          case T("Escape", t):
            h.options.escKey && (i = "close");
            break;
          case T("z", t):
            i = "toggleZoom";
            break;
          case T("ArrowLeft", t):
            e = "x";
            break;
          case T("ArrowUp", t):
            e = "y";
            break;
          case T("ArrowRight", t):
            e = "x", s = !0;
            break;
          case T("ArrowDown", t):
            s = !0, e = "y";
            break;
          case T("Tab", t):
            this.dt()
        }
        if (e) {
          n.preventDefault();
          let t = h.currSlide;
          h.options.arrowKeys && "x" === e && 1 < h.getNumItems() ? i = s ? "next" : "prev" : t && t.currZoomLevel > t.zoomLevels.fit && (t.pan[e] += s ? -80 : 80, t.panTo(t.pan.x, t.pan.y))
        }
        i && (n.preventDefault(), h[i]())
      }
    }
    ut(t) {
      var i = this.pswp.template;
      i && document !== t.target && i !== t.target && !i.contains(t.target) && i.focus()
    }
  }
  class F {
    constructor(t) {
      let i, {
          target: e,
          onComplete: s,
          transform: n,
          onFinish: h = () => {},
          duration: o = 333,
          easing: a = "cubic-bezier(.4,0,.22,1)"
        } = this.props = t,
        r = (this.onFinish = h, n ? "transform" : "opacity"),
        l = null != (i = t[r]) ? i : "";
      this.ft = e, this.wt = s, this.gt = !1, this.yt = this.yt.bind(this), this._t = setTimeout(() => {
        d(e, r, o, a), this._t = setTimeout(() => {
          e.addEventListener("transitionend", this.yt, !1), e.addEventListener("transitioncancel", this.yt, !1), this._t = setTimeout(() => {
            this.xt()
          }, o + 500), e.style[r] = l
        }, 30)
      }, 0)
    }
    yt(t) {
      t.target === this.ft && this.xt()
    }
    xt() {
      this.gt || (this.gt = !0, this.onFinish(), this.wt && this.wt())
    }
    destroy() {
      this._t && clearTimeout(this._t), d(this.ft), this.ft.removeEventListener("transitionend", this.yt, !1), this.ft.removeEventListener("transitioncancel", this.yt, !1), this.gt || this.xt()
    }
  }
  class B {
    constructor(t, i, e) {
      this.velocity = 1e3 * t, this.bt = i || .75, this.St = e || 12, this.zt = this.St, this.bt < 1 && (this.zt *= Math.sqrt(1 - this.bt * this.bt))
    }
    easeFrame(t, i) {
      let e, s = 0;
      i /= 1e3;
      var n, h = Math.E ** (-this.bt * this.St * i);
      return 1 === this.bt ? (e = this.velocity + this.St * t, s = (t + e * i) * h, this.velocity = s * -this.St + e * h) : this.bt < 1 && (e = 1 / this.zt * (this.bt * this.St * t + this.velocity), n = Math.cos(this.zt * i), i = Math.sin(this.zt * i), s = h * (t * n + e * i), this.velocity = s * -this.St * this.bt + h * (-this.zt * t * i + this.zt * e * n)), s
    }
  }
  class N {
    constructor(t) {
      this.props = t, this.Mt = 0;
      let {
        start: i,
        end: e,
        velocity: s,
        onUpdate: n,
        onComplete: h,
        onFinish: o = () => {},
        dampingRatio: a,
        naturalFrequency: r
      } = t, l = (this.onFinish = o, new B(s, a, r)), p = Date.now(), d = i - e, c = () => {
        this.Mt && (d = l.easeFrame(d, Date.now() - p), Math.abs(d) < 1 && Math.abs(l.velocity) < 50 ? (n(e), h && h(), this.onFinish()) : (p = Date.now(), n(d + e), this.Mt = requestAnimationFrame(c)))
      };
      this.Mt = requestAnimationFrame(c)
    }
    destroy() {
      0 <= this.Mt && cancelAnimationFrame(this.Mt), this.Mt = 0
    }
  }
  class H {
    constructor() {
      this.activeAnimations = []
    }
    startSpring(t) {
      this.Pt(t, !0)
    }
    startTransition(t) {
      this.Pt(t)
    }
    Pt(t, i) {
      let e = new(i ? N : F)(t);
      return this.activeAnimations.push(e), e.onFinish = () => this.stop(e), e
    }
    stop(t) {
      t.destroy();
      t = this.activeAnimations.indexOf(t); - 1 < t && this.activeAnimations.splice(t, 1)
    }
    stopAll() {
      this.activeAnimations.forEach(t => {
        t.destroy()
      }), this.activeAnimations = []
    }
    stopAllPan() {
      this.activeAnimations = this.activeAnimations.filter(t => !t.props.isPan || (t.destroy(), !1))
    }
    stopMainScroll() {
      this.activeAnimations = this.activeAnimations.filter(t => !t.props.isMainScroll || (t.destroy(), !1))
    }
    isPanRunning() {
      return this.activeAnimations.some(t => t.props.isPan)
    }
  }
  class k {
    constructor(t) {
      (this.pswp = t).events.add(t.element, "wheel", this.Ct.bind(this))
    }
    Ct(i) {
      i.preventDefault();
      var e = this.pswp.currSlide;
      let {
        deltaX: t,
        deltaY: s
      } = i;
      if (e && !this.pswp.dispatch("wheel", {
          originalEvent: i
        }).defaultPrevented)
        if (i.ctrlKey || this.pswp.options.wheelToZoom) {
          if (e.isZoomable()) {
            let t = -s;
            1 === i.deltaMode ? t *= .05 : t *= i.deltaMode ? 1 : .002, t = 2 ** t;
            var n = e.currZoomLevel * t;
            e.zoomTo(n, {
              x: i.clientX,
              y: i.clientY
            })
          }
        } else e.isPannable() && (1 === i.deltaMode && (t *= 18, s *= 18), e.panTo(e.pan.x - t, e.pan.y - s))
    }
  }
  class W {
    constructor(h, o) {
      var e, a = o.name || o.className;
      let r = o.html;
      if (!1 !== h.options[a]) {
        "string" == typeof h.options[a + "SVG"] && (r = h.options[a + "SVG"]), h.dispatch("uiElementCreate", {
          data: o
        });
        let t = "",
          s = (o.isButton ? t = (t += "pswp__button ") + (o.className || "pswp__button--" + o.name) : t += o.className || "pswp__" + o.name, o.isButton ? o.tagName || "button" : o.tagName || "div"),
          n = (s = s.toLowerCase(), l(t, s));
        if (o.isButton) {
          "button" === s && (n.type = "button");
          let t = o.title,
            i = o.ariaLabel,
            e = ((t = "string" == typeof h.options[a + "Title"] ? h.options[a + "Title"] : t) && (n.title = t), i || t);
          e && n.setAttribute("aria-label", e)
        }
        n.innerHTML = (t => {
          if ("string" == typeof t) return t;
          if (!t || !t.isCustomSVG) return "";
          let i = '<svg aria-hidden="true" class="pswp__icn" viewBox="0 0 %d %d" width="%d" height="%d">';
          return i = i.split("%d").join(t.size || 32), t.outlineID && (i += '<use class="pswp__icn-shadow" xlink:href="#' + t.outlineID + '"/>'), i = i + t.inner + "</svg>"
        })(r), o.onInit && o.onInit(n, h), o.onClick && (n.onclick = t => {
          "string" == typeof o.onClick ? h[o.onClick]() : "function" == typeof o.onClick && o.onClick(t, n, h)
        });
        a = o.appendTo || "bar";
        let i = h.element;
        "bar" === a ? (h.topBar || (h.topBar = l("pswp__top-bar pswp__hide-on-close", "div", h.scrollWrap)), i = h.topBar) : (n.classList.add("pswp__hide-on-close"), "wrapper" === a && (i = h.scrollWrap)), null != (e = i) && e.appendChild(h.applyFilters("uiElement", n, o))
      }
    }
  }

  function _(t, i, e) {
    t.classList.add("pswp__button--arrow"), t.setAttribute("aria-controls", "pswp__items"), i.on("change", () => {
      i.options.loop || (t.disabled = e ? !(i.currIndex < i.getNumItems() - 1) : !(0 < i.currIndex))
    })
  }
  let R = {
      name: "arrowPrev",
      className: "pswp__button--arrow--prev",
      title: "Previous",
      order: 10,
      isButton: !0,
      appendTo: "wrapper",
      html: {
        isCustomSVG: !0,
        size: 60,
        inner: '<path d="M29 43l-3 3-16-16 16-16 3 3-13 13 13 13z" id="pswp__icn-arrow"/>',
        outlineID: "pswp__icn-arrow"
      },
      onClick: "prev",
      onInit: _
    },
    U = {
      name: "arrowNext",
      className: "pswp__button--arrow--next",
      title: "Next",
      order: 11,
      isButton: !0,
      appendTo: "wrapper",
      html: {
        isCustomSVG: !0,
        size: 60,
        inner: '<use xlink:href="#pswp__icn-arrow"/>',
        outlineID: "pswp__icn-arrow"
      },
      onClick: "next",
      onInit: (t, i) => {
        _(t, i, !0)
      }
    },
    V = {
      name: "close",
      title: "Close",
      order: 20,
      isButton: !0,
      html: {
        isCustomSVG: !0,
        inner: '<path d="M24 10l-2-2-6 6-6-6-2 2 6 6-6 6 2 2 6-6 6 6 2-2-6-6z" id="pswp__icn-close"/>',
        outlineID: "pswp__icn-close"
      },
      onClick: "close"
    },
    X = {
      name: "zoom",
      title: "Zoom",
      order: 10,
      isButton: !0,
      html: {
        isCustomSVG: !0,
        inner: '<path d="M17.426 19.926a6 6 0 1 1 1.5-1.5L23 22.5 21.5 24l-4.074-4.074z" id="pswp__icn-zoom"/><path fill="currentColor" class="pswp__zoom-icn-bar-h" d="M11 16v-2h6v2z"/><path fill="currentColor" class="pswp__zoom-icn-bar-v" d="M13 12h2v6h-2z"/>',
        outlineID: "pswp__icn-zoom"
      },
      onClick: "toggleZoom"
    },
    G = {
      name: "preloader",
      appendTo: "bar",
      order: 7,
      html: {
        isCustomSVG: !0,
        inner: '<path fill-rule="evenodd" clip-rule="evenodd" d="M21.2 16a5.2 5.2 0 1 1-5.2-5.2V8a8 8 0 1 0 8 8h-2.8Z" id="pswp__icn-loading"/>',
        outlineID: "pswp__icn-loading"
      },
      onInit: (i, e) => {
        let s, n = null,
          h = t => {
            s !== t && (s = t, i.classList.toggle("pswp__preloader--active", t))
          },
          o = () => {
            var t;
            null != (t = e.currSlide) && t.content.isLoading() ? n = n || setTimeout(() => {
              var t;
              h(Boolean(null == (t = e.currSlide) ? void 0 : t.content.isLoading())), n = null
            }, e.options.preloaderDelay) : (h(!1), n && (clearTimeout(n), n = null))
          };
        e.on("change", o), e.on("loadComplete", t => {
          e.currSlide === t.slide && o()
        }), e.ui && (e.ui.updatePreloaderVisibility = o)
      }
    },
    q = {
      name: "counter",
      order: 5,
      onInit: (t, i) => {
        i.on("change", () => {
          t.innerText = i.currIndex + 1 + i.options.indexIndicatorSep + i.getNumItems()
        })
      }
    };

  function M(t, i) {
    t.classList.toggle("pswp--zoomed-in", i)
  }
  class Y {
    constructor(t) {
      this.pswp = t, this.isRegistered = !1, this.uiElementsData = [], this.items = [], this.updatePreloaderVisibility = () => {}, this.Tt = void 0
    }
    init() {
      let i = this.pswp;
      this.isRegistered = !1, this.uiElementsData = [V, R, U, X, G, q], i.dispatch("uiRegister"), this.uiElementsData.sort((t, i) => (t.order || 0) - (i.order || 0)), this.items = [], this.isRegistered = !0, this.uiElementsData.forEach(t => {
        this.registerElement(t)
      }), i.on("change", () => {
        var t;
        null != (t = i.element) && t.classList.toggle("pswp--one-slide", 1 === i.getNumItems())
      }), i.on("zoomPanUpdate", () => this.At())
    }
    registerElement(t) {
      this.isRegistered ? this.items.push(new W(this.pswp, t)) : this.uiElementsData.push(t)
    }
    At() {
      var i, {
        template: e,
        currSlide: s,
        options: n
      } = this.pswp;
      if (!this.pswp.opener.isClosing && e && s) {
        let t = s.currZoomLevel;
        (t = this.pswp.opener.isOpen ? t : s.zoomLevels.initial) !== this.Tt && (this.Tt = t, i = s.zoomLevels.initial - s.zoomLevels.secondary, Math.abs(i) < .01 || !s.isZoomable() ? (M(e, !1), e.classList.remove("pswp--zoom-allowed")) : (e.classList.add("pswp--zoom-allowed"), M(e, (t === s.zoomLevels.initial ? s.zoomLevels.secondary : s.zoomLevels.initial) <= t), "zoom" !== n.imageClickAction && "zoom-or-close" !== n.imageClickAction || e.classList.add("pswp--click-to-zoom")))
      }
    }
  }
  class K {
    constructor(t, i) {
      this.type = t, this.defaultPrevented = !1, i && Object.assign(this, i)
    }
    preventDefault() {
      this.defaultPrevented = !0
    }
  }
  class $ {
    constructor(i, t) {
      if (this.element = l("pswp__img pswp__img--placeholder", i ? "img" : "div", t), i) {
        let t = this.element;
        t.decoding = "async", t.alt = "", t.src = i, t.setAttribute("role", "presentation")
      }
      this.element.setAttribute("aria-hidden", "true")
    }
    setDisplayedSize(t, i) {
      this.element && ("IMG" === this.element.tagName ? (s(this.element, 250, "auto"), this.element.style.transformOrigin = "0 0", this.element.style.transform = a(0, 0, t / 250)) : s(this.element, t, i))
    }
    destroy() {
      var t;
      null != (t = this.element) && t.parentNode && this.element.remove(), this.element = null
    }
  }
  class J {
    constructor(t, i, e) {
      this.instance = i, this.data = t, this.index = e, this.element = void 0, this.placeholder = void 0, this.slide = void 0, this.displayedImageWidth = 0, this.displayedImageHeight = 0, this.width = Number(this.data.w) || Number(this.data.width) || 0, this.height = Number(this.data.h) || Number(this.data.height) || 0, this.isAttached = !1, this.hasSlide = !1, this.isDecoding = !1, this.state = "idle", this.data.type ? this.type = this.data.type : this.data.src ? this.type = "image" : this.type = "html", this.instance.dispatch("contentInit", {
        content: this
      })
    }
    removePlaceholder() {
      this.placeholder && !this.keepPlaceholder() && setTimeout(() => {
        this.placeholder && (this.placeholder.destroy(), this.placeholder = void 0)
      }, 1e3)
    }
    load(t, i) {
      if (this.slide && this.usePlaceholder())
        if (this.placeholder) {
          let t = this.placeholder.element;
          t && !t.parentElement && this.slide.container.prepend(t)
        } else {
          let t = this.instance.applyFilters("placeholderSrc", !(!this.data.msrc || !this.slide.isFirstSlide) && this.data.msrc, this);
          this.placeholder = new $(t, this.slide.container)
        } this.element && !i || this.instance.dispatch("contentLoad", {
        content: this,
        isLazy: t
      }).defaultPrevented || (this.isImageContent() ? (this.element = l("pswp__img", "img"), this.displayedImageWidth && this.loadImage(t)) : (this.element = l("pswp__content", "div"), this.element.innerHTML = this.data.html || ""), i && this.slide && this.slide.updateContentSize(!0))
    }
    loadImage(t) {
      var i;
      this.isImageContent() && this.element && !this.instance.dispatch("contentLoadImage", {
        content: this,
        isLazy: t
      }).defaultPrevented && (t = this.element, this.updateSrcsetSizes(), this.data.srcset && (t.srcset = this.data.srcset), t.src = null != (i = this.data.src) ? i : "", t.alt = null != (i = this.data.alt) ? i : "", this.state = e, t.complete ? this.onLoaded() : (t.onload = () => {
        this.onLoaded()
      }, t.onerror = () => {
        this.onError()
      }))
    }
    setSlide(t) {
      this.slide = t, this.hasSlide = !0, this.instance = t.pswp
    }
    onLoaded() {
      this.state = t, this.slide && this.element && (this.instance.dispatch("loadComplete", {
        slide: this.slide,
        content: this
      }), this.slide.isActive && this.slide.heavyAppended && !this.element.parentNode && (this.append(), this.slide.updateContentSize(!0)), this.state !== t && this.state !== i || this.removePlaceholder())
    }
    onError() {
      this.state = i, this.slide && (this.displayError(), this.instance.dispatch("loadComplete", {
        slide: this.slide,
        isError: !0,
        content: this
      }), this.instance.dispatch("loadError", {
        slide: this.slide,
        content: this
      }))
    }
    isLoading() {
      return this.instance.applyFilters("isContentLoading", this.state === e, this)
    }
    isError() {
      return this.state === i
    }
    isImageContent() {
      return "image" === this.type
    }
    setDisplayedSize(t, i) {
      var e;
      this.element && (this.placeholder && this.placeholder.setDisplayedSize(t, i), !this.instance.dispatch("contentResize", {
        content: this,
        width: t,
        height: i
      }).defaultPrevented) && (s(this.element, t, i), this.isImageContent()) && !this.isError() && (e = !this.displayedImageWidth && t, this.displayedImageWidth = t, this.displayedImageHeight = i, e ? this.loadImage(!1) : this.updateSrcsetSizes(), this.slide) && this.instance.dispatch("imageSizeChange", {
        slide: this.slide,
        width: t,
        height: i,
        content: this
      })
    }
    isZoomable() {
      return this.instance.applyFilters("isContentZoomable", this.isImageContent() && this.state !== i, this)
    }
    updateSrcsetSizes() {
      var t, i;
      this.isImageContent() && this.element && this.data.srcset && (t = this.element, i = this.instance.applyFilters("srcsetSizesWidth", this.displayedImageWidth, this), !t.dataset.largestUsedSize || i > parseInt(t.dataset.largestUsedSize, 10)) && (t.sizes = i + "px", t.dataset.largestUsedSize = String(i))
    }
    usePlaceholder() {
      return this.instance.applyFilters("useContentPlaceholder", this.isImageContent(), this)
    }
    lazyLoad() {
      this.instance.dispatch("contentLazyLoad", {
        content: this
      }).defaultPrevented || this.load(!0)
    }
    keepPlaceholder() {
      return this.instance.applyFilters("isKeepingPlaceholder", this.isLoading(), this)
    }
    destroy() {
      this.hasSlide = !1, this.slide = void 0, this.instance.dispatch("contentDestroy", {
        content: this
      }).defaultPrevented || (this.remove(), this.placeholder && (this.placeholder.destroy(), this.placeholder = void 0), this.isImageContent() && this.element && (this.element.onload = null, this.element.onerror = null, this.element = void 0))
    }
    displayError() {
      if (this.slide) {
        let t, i, e = l("pswp__error-msg", "div");
        e.innerText = null != (t = null == (i = this.instance.options) ? void 0 : i.errorMsg) ? t : "", e = this.instance.applyFilters("contentErrorElement", e, this), this.element = l("pswp__content pswp__error-msg-container", "div"), this.element.appendChild(e), this.slide.container.innerText = "", this.slide.container.appendChild(this.element), this.slide.updateContentSize(!0), this.removePlaceholder()
      }
    }
    append() {
      var t;
      !this.isAttached && this.element && (this.isAttached = !0, this.state === i ? this.displayError() : this.instance.dispatch("contentAppend", {
        content: this
      }).defaultPrevented || (t = "decode" in this.element, this.isImageContent() ? t && this.slide && (!this.slide.isActive || n()) ? (this.isDecoding = !0, this.element.decode().catch(() => {}).finally(() => {
        this.isDecoding = !1, this.appendImage()
      })) : this.appendImage() : this.slide && !this.element.parentNode && this.slide.container.appendChild(this.element)))
    }
    activate() {
      !this.instance.dispatch("contentActivate", {
        content: this
      }).defaultPrevented && this.slide && (this.isImageContent() && this.isDecoding && !n() ? this.appendImage() : this.isError() && this.load(!1, !0), this.slide.holderElement) && this.slide.holderElement.setAttribute("aria-hidden", "false")
    }
    deactivate() {
      this.instance.dispatch("contentDeactivate", {
        content: this
      }), this.slide && this.slide.holderElement && this.slide.holderElement.setAttribute("aria-hidden", "true")
    }
    remove() {
      this.isAttached = !1, this.instance.dispatch("contentRemove", {
        content: this
      }).defaultPrevented || (this.element && this.element.parentNode && this.element.remove(), this.placeholder && this.placeholder.element && this.placeholder.element.remove())
    }
    appendImage() {
      !this.isAttached || this.instance.dispatch("contentAppendImage", {
        content: this
      }).defaultPrevented || (this.slide && this.element && !this.element.parentNode && this.slide.container.appendChild(this.element), this.state !== t && this.state !== i) || this.removePlaceholder()
    }
  }

  function O(t, i, e) {
    var s = i.createContentFromData(t, e);
    let n;
    var h = i.options;
    return h && (n = new x(h, t, -1), h = w(h, i.pswp ? i.pswp.viewportSize : g(h, i), t, e), n.update(s.width, s.height, h)), s.lazyLoad(), n && s.setDisplayedSize(Math.ceil(s.width * n.initial), Math.ceil(s.height * n.initial)), s
  }
  class j {
    constructor(t) {
      this.pswp = t, this.limit = Math.max(t.options.preload[0] + t.options.preload[1] + 1, 5), this.Dt = []
    }
    updateLazy(i) {
      var e = this.pswp;
      if (!e.dispatch("lazyLoad").defaultPrevented) {
        var s = e.options.preload,
          n = void 0 === i || 0 <= i;
        let t;
        for (t = 0; t <= s[1]; t++) this.loadSlideByIndex(e.currIndex + (n ? t : -t));
        for (t = 1; t <= s[0]; t++) this.loadSlideByIndex(e.currIndex + (n ? -t : t))
      }
    }
    loadSlideByIndex(t) {
      var t = this.pswp.getLoopedIndex(t);
      this.getContentByIndex(t) || (t = ((t, i) => {
        var e = i.getItemData(t);
        if (!i.dispatch("lazyLoadSlide", {
            index: t,
            itemData: e
          }).defaultPrevented) return O(e, i, t)
      })(t, this.pswp)) && this.addToCache(t)
    }
    getContentBySlide(t) {
      let i = this.getContentByIndex(t.index);
      return i || (i = this.pswp.createContentFromData(t.data, t.index), this.addToCache(i)), i.setSlide(t), i
    }
    addToCache(t) {
      if (this.removeByIndex(t.index), this.Dt.push(t), this.Dt.length > this.limit) {
        let t = this.Dt.findIndex(t => !t.isAttached && !t.hasSlide); - 1 !== t && this.Dt.splice(t, 1)[0].destroy()
      }
    }
    removeByIndex(i) {
      var t = this.Dt.findIndex(t => t.index === i); - 1 !== t && this.Dt.splice(t, 1)
    }
    getContentByIndex(i) {
      return this.Dt.find(t => t.index === i)
    }
    destroy() {
      this.Dt.forEach(t => t.destroy()), this.Dt = []
    }
  }
  let E = .003;
  class Q {
    constructor(t) {
      this.pswp = t, this.isClosed = !0, this.isOpen = !1, this.isClosing = !1, this.isOpening = !1, this.It = void 0, this.Et = !1, this.Lt = !1, this.kt = !1, this.Zt = !1, this.Bt = void 0, this.Ft = void 0, this.Ot = void 0, this.Rt = void 0, this.Nt = void 0, this.Ut = this.Ut.bind(this), t.on("firstZoomPan", this.Ut)
    }
    open() {
      this.Ut(), this.Pt()
    }
    close() {
      var t;
      this.isClosed || this.isClosing || this.isOpening || (t = this.pswp.currSlide, this.isOpen = !1, this.isOpening = !1, this.isClosing = !0, this.It = this.pswp.options.hideAnimationDuration, t && t.currZoomLevel * t.width >= this.pswp.options.maxWidthToAnimate && (this.It = 0), this.Vt(), setTimeout(() => {
        this.Pt()
      }, this.Lt ? 30 : 0))
    }
    Ut() {
      var t;
      this.pswp.off("firstZoomPan", this.Ut), this.isOpening || (t = this.pswp.currSlide, this.isOpening = !0, this.isClosing = !1, this.It = this.pswp.options.showAnimationDuration, t && t.zoomLevels.initial * t.width >= this.pswp.options.maxWidthToAnimate && (this.It = 0), this.Vt())
    }
    Vt() {
      var t = this.pswp,
        i = this.pswp.currSlide,
        e = t.options;
      "fade" === e.showHideAnimationType ? (e.showHideOpacity = !0, this.Nt = void 0) : "none" === e.showHideAnimationType ? (e.showHideOpacity = !1, this.It = 0, this.Nt = void 0) : this.isOpening && t.Gt ? this.Nt = t.Gt : this.Nt = this.pswp.getThumbBounds(), this.Bt = null == i ? void 0 : i.getPlaceholderElement(), t.animations.stopAll(), this.Et = Boolean(this.It && 50 < this.It), this.$t = Boolean(this.Nt) && (null == i ? void 0 : i.content.usePlaceholder()) && (!this.isClosing || !t.mainScroll.isShifted()), this.$t ? this.kt = null != (e = e.showHideOpacity) && e : (this.kt = !0, this.isOpening && i && (i.zoomAndPanToInitial(), i.applyCurrentZoomPan())), this.Zt = !this.kt && this.pswp.options.bgOpacity > E, this.Ft = this.kt ? t.element : t.bg, this.Et ? (this.$t && this.Nt && this.Nt.innerRect ? (this.Lt = !0, this.Ot = this.pswp.container, this.Rt = null == (e = this.pswp.currSlide) ? void 0 : e.holderElement, t.container && (t.container.style.overflow = "hidden", t.container.style.width = t.viewportSize.x + "px")) : this.Lt = !1, this.isOpening ? (this.kt ? (t.element && (t.element.style.opacity = String(E)), t.applyBgOpacity(1)) : (this.Zt && t.bg && (t.bg.style.opacity = String(E)), t.element && (t.element.style.opacity = "1")), this.$t && (this.qt(), this.Bt) && (this.Bt.style.willChange = "transform", this.Bt.style.opacity = String(E))) : this.isClosing && (t.mainScroll.itemHolders[0] && (t.mainScroll.itemHolders[0].el.style.display = "none"), t.mainScroll.itemHolders[2] && (t.mainScroll.itemHolders[2].el.style.display = "none"), this.Lt) && 0 !== t.mainScroll.x && (t.mainScroll.resetPosition(), t.mainScroll.resize())) : (this.It = 0, this.$t = !1, this.Zt = !1, this.kt = !0, this.isOpening && (t.element && (t.element.style.opacity = String(E)), t.applyBgOpacity(1)))
    }
    Pt() {
      this.isOpening && this.Et && this.Bt && "IMG" === this.Bt.tagName ? new Promise(t => {
        let i = !1,
          e = !0;
        var s = this.Bt;
        ("decode" in s ? s.decode().catch(() => {}) : s.complete ? Promise.resolve(s) : new Promise((t, i) => {
          s.onload = () => t(s), s.onerror = i
        })).finally(() => {
          i = !0, e || t(!0)
        }), setTimeout(() => {
          e = !1, i && t(!0)
        }, 50), setTimeout(t, 250)
      }).finally(() => this.Ht()) : this.Ht()
    }
    Ht() {
      var t;
      null != (t = this.pswp.element) && t.style.setProperty("--pswp-transition-duration", this.It + "ms"), this.pswp.dispatch(this.isOpening ? "openingAnimationStart" : "closingAnimationStart"), this.pswp.dispatch("initialZoom" + (this.isOpening ? "In" : "Out")), null != (t = this.pswp.element) && t.classList.toggle("pswp--ui-visible", this.isOpening), this.isOpening ? (this.Bt && (this.Bt.style.opacity = "1"), this.Kt()) : this.isClosing && this.Wt(), this.Et || this.jt()
    }
    jt() {
      var t = this.pswp;
      this.isOpen = this.isOpening, this.isClosed = this.isClosing, this.isOpening = !1, this.isClosing = !1, t.dispatch(this.isOpen ? "openingAnimationEnd" : "closingAnimationEnd"), t.dispatch("initialZoom" + (this.isOpen ? "InEnd" : "OutEnd")), this.isClosed ? t.destroy() : this.isOpen && (this.$t && t.container && (t.container.style.overflow = "visible", t.container.style.width = "100%"), null != (t = t.currSlide)) && t.applyCurrentZoomPan()
    }
    Kt() {
      var t = this.pswp;
      this.$t && (this.Lt && this.Ot && this.Rt && (this.Xt(this.Ot, "transform", "translate3d(0,0,0)"), this.Xt(this.Rt, "transform", "none")), t.currSlide) && (t.currSlide.zoomAndPanToInitial(), this.Xt(t.currSlide.container, "transform", t.currSlide.getCurrentTransform())), this.Zt && t.bg && this.Xt(t.bg, "opacity", String(t.options.bgOpacity)), this.kt && t.element && this.Xt(t.element, "opacity", "1")
    }
    Wt() {
      var t = this.pswp;
      this.$t && this.qt(!0), this.Zt && .01 < t.bgOpacity && t.bg && this.Xt(t.bg, "opacity", "0"), this.kt && t.element && this.Xt(t.element, "opacity", "0")
    }
    qt(o) {
      if (this.Nt) {
        let t = this.pswp,
          n = this.Nt.innerRect,
          {
            currSlide: i,
            viewportSize: h
          } = t;
        if (this.Lt && n && this.Ot && this.Rt) {
          let t = -h.x + (this.Nt.x - n.x) + n.w,
            i = -h.y + (this.Nt.y - n.y) + n.h,
            e = h.x - n.w,
            s = h.y - n.h;
          o ? (this.Xt(this.Ot, "transform", a(t, i)), this.Xt(this.Rt, "transform", a(e, s))) : (r(this.Ot, t, i), r(this.Rt, e, s))
        }
        i && (c(i.pan, n || this.Nt), i.currZoomLevel = this.Nt.w / i.width, o ? this.Xt(i.container, "transform", i.getCurrentTransform()) : i.applyCurrentZoomPan())
      }
    }
    Xt(e, s, n) {
      if (this.It) {
        let t = this.pswp.animations,
          i = {
            duration: this.It,
            easing: this.pswp.options.easing,
            onComplete: () => {
              t.activeAnimations.length || this.jt()
            },
            target: e
          };
        i[s] = n, t.startTransition(i)
      } else e.style[s] = n
    }
  }
  let tt = {
    allowPanToNext: !0,
    spacing: .1,
    loop: !0,
    pinchToClose: !0,
    closeOnVerticalDrag: !0,
    hideAnimationDuration: 333,
    showAnimationDuration: 333,
    zoomAnimationDuration: 333,
    escKey: !0,
    arrowKeys: !0,
    trapFocus: !0,
    returnFocus: !0,
    maxWidthToAnimate: 4e3,
    clickToCloseNonZoomable: !0,
    imageClickAction: "zoom-or-close",
    bgClickAction: "close",
    tapAction: "toggle-controls",
    doubleTapAction: "zoom",
    indexIndicatorSep: " / ",
    preloaderDelay: 2e3,
    bgOpacity: .8,
    index: 0,
    errorMsg: "The image cannot be loaded",
    preload: [1, 2],
    easing: "cubic-bezier(.4,0,.22,1)"
  };
  return class extends class extends class {
    constructor() {
      this.Yt = {}, this.Jt = {}, this.pswp = void 0, this.options = void 0
    }
    addFilter(t, i, e = 100) {
      var s;
      this.Jt[t] || (this.Jt[t] = []), null != (s = this.Jt[t]) && s.push({
        fn: i,
        priority: e
      }), null != (s = this.Jt[t]) && s.sort((t, i) => t.priority - i.priority), null != (s = this.pswp) && s.addFilter(t, i, e)
    }
    removeFilter(t, i) {
      this.Jt[t] && (this.Jt[t] = this.Jt[t].filter(t => t.fn !== i)), this.pswp && this.pswp.removeFilter(t, i)
    }
    applyFilters(t, ...i) {
      return null != (t = this.Jt[t]) && t.forEach(t => {
        i[0] = t.fn.apply(this, i)
      }), i[0]
    }
    on(t, i) {
      var e;
      this.Yt[t] || (this.Yt[t] = []), null != (e = this.Yt[t]) && e.push(i), null != (e = this.pswp) && e.on(t, i)
    }
    off(t, i) {
      var e;
      this.Yt[t] && (this.Yt[t] = this.Yt[t].filter(t => i !== t)), null != (e = this.pswp) && e.off(t, i)
    }
    dispatch(t, i) {
      if (this.pswp) return this.pswp.dispatch(t, i);
      let e = new K(t, i);
      return null != (i = this.Yt[t]) && i.forEach(t => {
        t.call(this, e)
      }), e
    }
  } {
    getNumItems() {
      let t, i = 0;
      var e = null == (t = this.options) ? void 0 : t.dataSource,
        s = (e && "length" in e ? i = e.length : e && "gallery" in e && (e.items || (e.items = this.Qt(e.gallery)), e.items) && (i = e.items.length), this.dispatch("numItems", {
          dataSource: e,
          numItems: i
        }));
      return this.applyFilters("numItems", s.numItems, e)
    }
    createContentFromData(t, i) {
      return new J(t, this, i)
    }
    getItemData(t) {
      var i = null == (i = this.options) ? void 0 : i.dataSource;
      let e = {},
        s = (Array.isArray(i) ? e = i[t] : i && "gallery" in i && (i.items || (i.items = this.Qt(i.gallery)), e = i.items[t]), e);
      s instanceof Element && (s = this.ti(s));
      i = this.dispatch("itemData", {
        itemData: s || {},
        index: t
      });
      return this.applyFilters("itemData", i.itemData, t)
    }
    Qt(t) {
      var i;
      return null != (i = this.options) && i.children || null != (i = this.options) && i.childSelector ? ((t, i, e = document) => {
        let s = [];
        return t instanceof Element ? s = [t] : t instanceof NodeList || Array.isArray(t) ? s = Array.from(t) : (t = "string" == typeof t ? t : i) && (s = Array.from(e.querySelectorAll(t))), s
      })(this.options.children, this.options.childSelector, t) || [] : [t]
    }
    ti(t) {
      var i, e = {
          element: t
        },
        s = "A" === t.tagName ? t : t.querySelector("a");
      return s && (e.src = s.dataset.pswpSrc || s.href, s.dataset.pswpSrcset && (e.srcset = s.dataset.pswpSrcset), e.width = s.dataset.pswpWidth ? parseInt(s.dataset.pswpWidth, 10) : 0, e.height = s.dataset.pswpHeight ? parseInt(s.dataset.pswpHeight, 10) : 0, e.w = e.width, e.h = e.height, s.dataset.pswpType && (e.type = s.dataset.pswpType), (i = t.querySelector("img")) && (e.msrc = i.currentSrc || i.src, e.alt = null != (i = i.getAttribute("alt")) ? i : ""), s.dataset.pswpCropped || s.dataset.cropped) && (e.thumbCropped = !0), this.applyFilters("domItemData", e, t, s)
    }
    lazyLoadData(t, i) {
      return O(t, this, i)
    }
  } {
    constructor(t) {
      super(), this.options = this.ii(t || {}), this.offset = {
        x: 0,
        y: 0
      }, this.si = {
        x: 0,
        y: 0
      }, this.viewportSize = {
        x: 0,
        y: 0
      }, this.bgOpacity = 1, this.currIndex = 0, this.potentialIndex = 0, this.isOpen = !1, this.isDestroying = !1, this.hasMouse = !1, this.hi = {}, this.Gt = void 0, this.topBar = void 0, this.element = void 0, this.template = void 0, this.container = void 0, this.scrollWrap = void 0, this.currSlide = void 0, this.events = new h, this.animations = new H, this.mainScroll = new A(this), this.gestures = new C(this), this.opener = new Q(this), this.keyboard = new Z(this), this.contentLoader = new j(this)
    }
    init() {
      if (this.isOpen || this.isDestroying) return !1;
      this.isOpen = !0, this.dispatch("init"), this.dispatch("beforeOpen"), this.ei();
      let t = "pswp--open";
      return this.gestures.supportsTouch && (t += " pswp--touch"), this.options.mainClass && (t += " " + this.options.mainClass), this.element && (this.element.className += " " + t), this.currIndex = this.options.index || 0, this.potentialIndex = this.currIndex, this.dispatch("firstUpdate"), this.scrollWheel = new k(this), (Number.isNaN(this.currIndex) || this.currIndex < 0 || this.currIndex >= this.getNumItems()) && (this.currIndex = 0), this.gestures.supportsTouch || this.mouseDetected(), this.updateSize(), this.offset.y = window.pageYOffset, this.hi = this.getItemData(this.currIndex), this.dispatch("gettingData", {
        index: this.currIndex,
        data: this.hi,
        slide: void 0
      }), this.Gt = this.getThumbBounds(), this.dispatch("initialLayout"), this.on("openingAnimationEnd", () => {
        var t = this.mainScroll.itemHolders;
        t[0] && (t[0].el.style.display = "block", this.setContent(t[0], this.currIndex - 1)), t[2] && (t[2].el.style.display = "block", this.setContent(t[2], this.currIndex + 1)), this.appendHeavy(), this.contentLoader.updateLazy(), this.events.add(window, "resize", this.ni.bind(this)), this.events.add(window, "scroll", this.oi.bind(this)), this.dispatch("bindEvents")
      }), this.mainScroll.itemHolders[1] && this.setContent(this.mainScroll.itemHolders[1], this.currIndex), this.dispatch("change"), this.opener.open(), this.dispatch("afterInit"), !0
    }
    getLoopedIndex(t) {
      var i = this.getNumItems();
      return this.options.loop && (i - 1 < t && (t -= i), t < 0) && (t += i), u(t, 0, i - 1)
    }
    appendHeavy() {
      this.mainScroll.itemHolders.forEach(t => {
        null != (t = t.slide) && t.appendHeavy()
      })
    }
    goTo(t) {
      this.mainScroll.moveIndexBy(this.getLoopedIndex(t) - this.potentialIndex)
    }
    next() {
      this.goTo(this.potentialIndex + 1)
    }
    prev() {
      this.goTo(this.potentialIndex - 1)
    }
    zoomTo(...t) {
      var i;
      null != (i = this.currSlide) && i.zoomTo(...t)
    }
    toggleZoom() {
      var t;
      null != (t = this.currSlide) && t.toggleZoom()
    }
    close() {
      this.opener.isOpen && !this.isDestroying && (this.isDestroying = !0, this.dispatch("close"), this.events.removeAll(), this.opener.close())
    }
    destroy() {
      var t;
      this.isDestroying ? (this.dispatch("destroy"), this.Yt = {}, this.scrollWrap && (this.scrollWrap.ontouchmove = null, this.scrollWrap.ontouchend = null), null != (t = this.element) && t.remove(), this.mainScroll.itemHolders.forEach(t => {
        null != (t = t.slide) && t.destroy()
      }), this.contentLoader.destroy(), this.events.removeAll()) : (this.options.showHideAnimationType = "none", this.close())
    }
    refreshSlideContent(o) {
      this.contentLoader.removeByIndex(o), this.mainScroll.itemHolders.forEach((t, i) => {
        let e, s, n = (null != (e = null == (s = this.currSlide) ? void 0 : s.index) ? e : 0) - 1 + i,
          h;
        (n = this.canLoop() ? this.getLoopedIndex(n) : n) === o && (this.setContent(t, o, !0), 1 === i) && (this.currSlide = t.slide, null != (h = t.slide) && h.setIsActive(!0))
      }), this.dispatch("change")
    }
    setContent(t, i, e) {
      if (this.canLoop() && (i = this.getLoopedIndex(i)), t.slide) {
        if (t.slide.index === i && !e) return;
        t.slide.destroy(), t.slide = void 0
      }!this.canLoop() && (i < 0 || i >= this.getNumItems()) || (e = this.getItemData(i), t.slide = new S(e, i, this), i === this.currIndex && (this.currSlide = t.slide), t.slide.append(t.el))
    }
    getViewportCenterPoint() {
      return {
        x: this.viewportSize.x / 2,
        y: this.viewportSize.y / 2
      }
    }
    updateSize(t) {
      var i;
      this.isDestroying || (i = g(this.options, this), !t && m(i, this.si)) || (c(this.si, i), this.dispatch("beforeResize"), c(this.viewportSize, this.si), this.oi(), this.dispatch("viewportSize"), this.mainScroll.resize(this.opener.isOpen), !this.hasMouse && window.matchMedia("(any-hover: hover)").matches && this.mouseDetected(), this.dispatch("resize"))
    }
    applyBgOpacity(t) {
      this.bgOpacity = Math.max(t, 0), this.bg && (this.bg.style.opacity = String(this.bgOpacity * this.options.bgOpacity))
    }
    mouseDetected() {
      var t;
      this.hasMouse || (this.hasMouse = !0, null == (t = this.element)) || t.classList.add("pswp--has_mouse")
    }
    ni() {
      this.updateSize(), /iPhone|iPad|iPod/i.test(window.navigator.userAgent) && setTimeout(() => {
        this.updateSize()
      }, 500)
    }
    oi() {
      this.setScrollOffset(0, window.pageYOffset)
    }
    setScrollOffset(t, i) {
      this.offset.x = t, this.offset.y = i, this.dispatch("updateScrollOffset")
    }
    ei() {
      this.element = l("pswp", "div"), this.element.setAttribute("tabindex", "-1"), this.element.setAttribute("role", "dialog"), this.template = this.element, this.bg = l("pswp__bg", "div", this.element), this.scrollWrap = l("pswp__scroll-wrap", "section", this.element), this.container = l("pswp__container", "div", this.scrollWrap), this.scrollWrap.setAttribute("aria-roledescription", "carousel"), this.container.setAttribute("aria-live", "off"), this.container.setAttribute("id", "pswp__items"), this.mainScroll.appendHolders(), this.ui = new Y(this), this.ui.init(), (this.options.appendToEl || document.body).appendChild(this.element)
    }
    getThumbBounds() {
      {
        var e = this.currIndex,
          s = this.currSlide ? this.currSlide.data : this.hi,
          n = this;
        if ((l = n.dispatch("thumbBounds", {
            index: e,
            itemData: s,
            instance: n
          })).thumbBounds) return l.thumbBounds;
        var h, o, a, r, l = s.element;
        let t, i;
        if (l && !1 !== n.options.thumbSelector) {
          let t = n.options.thumbSelector || "img";
          i = l.matches(t) ? l : l.querySelector(t)
        }
        return (i = n.applyFilters("thumbEl", i, s, e)) && (t = s.thumbCropped ? (l = i, h = s.width || s.w || 0, o = s.height || s.h || 0, l = l.getBoundingClientRect(), a = l.width / h, r = (l.width - h * (a = (r = l.height / o) < a ? a : r)) / 2, o = (l.height - o * a) / 2, (h = {
          x: l.left + r,
          y: l.top + o,
          w: h * a
        }).innerRect = {
          w: l.width,
          h: l.height,
          x: r,
          y: o
        }, h) : {
          x: (a = i.getBoundingClientRect()).left,
          y: a.top,
          w: a.width
        }), n.applyFilters("thumbBounds", t, s, e)
      }
    }
    canLoop() {
      return this.options.loop && 2 < this.getNumItems()
    }
    ii(t) {
      return window.matchMedia("(prefers-reduced-motion), (update: slow)").matches && (t.showHideAnimationType = "none", t.zoomAnimationDuration = 0), {
        ...tt,
        ...t
      }
    }
  }
});